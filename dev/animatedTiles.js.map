{"version":3,"file":"animatedTiles.js","sources":["webpack://[name]/webpack/universalModuleDefinition","webpack://[name]/webpack/bootstrap","webpack://[name]/./src/plugin/main.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"animatedTiles\"] = factory();\n\telse\n\t\troot[\"animatedTiles\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./dev/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/plugin/main.js\");\n","'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @author       Niklas Berg <nkholski@niklasberg.se>\n * @copyright    2018 Niklas Berg\n * @license      {@link https://github.com/nkholski/phaser3-animated-tiles/blob/master/LICENSE|MIT License}\n */\n\n//\n// This plugin is based on Photonstorms Phaser 3 plugin template with added support for ES6.\n// \n\nvar AnimatedTiles = function (_Phaser$Plugins$Scene) {\n    _inherits(AnimatedTiles, _Phaser$Plugins$Scene);\n\n    /*\n     TODO: \n    1. Fix property names which is a mess after adding support for multiple maps, tilesets and layers.\n    2. Helper functions: Get mapIndex by passing a map (and maybe support it as argument to methods), Get layerIndex, get tile index from properties.\n    \n    */\n    function AnimatedTiles(scene, pluginManager) {\n        _classCallCheck(this, AnimatedTiles);\n\n        // TileMap the plugin belong to. \n        // TODO: Array or object for multiple tilemaps support\n        // TODO: reference to layers too, and which is activated or not\n        var _this = _possibleConstructorReturn(this, (AnimatedTiles.__proto__ || Object.getPrototypeOf(AnimatedTiles)).call(this, scene, pluginManager));\n\n        _this.map = null;\n\n        // Array with all tiles to animate\n        // TODO: Turn on and off certain tiles.\n        _this.animatedTiles = [];\n\n        // Global playback rate\n        _this.rate = 1;\n\n        // Should the animations play or not?\n        _this.active = false;\n\n        // Should the animations play or not per layer. If global active is false this value makes no difference\n        _this.activeLayer = [];\n\n        // Obey timescale?\n        _this.followTimeScale = true;\n\n        if (!scene.sys.settings.isBooted) {\n            scene.sys.events.once('boot', _this.boot, _this);\n        }\n        return _this;\n    }\n\n    //  Called when the Plugin is booted by the PluginManager.\n    //  If you need to reference other systems in the Scene (like the Loader or DisplayList) then set-up those references now, not in the constructor.\n\n\n    _createClass(AnimatedTiles, [{\n        key: 'boot',\n        value: function boot() {\n            var eventEmitter = this.systems.events;\n            eventEmitter.on('postupdate', this.postUpdate, this);\n            eventEmitter.on('shutdown', this.shutdown, this);\n            eventEmitter.on('destroy', this.destroy, this);\n        }\n\n        // Initilize support for animated tiles on given map\n\n    }, {\n        key: 'init',\n        value: function init(map) {\n            // TODO: Check if map is initilized already, if so do it again but overwrite the old.\n            var mapAnimData = this.getAnimatedTiles(map);\n            var animatedTiles = {\n                map: map,\n                animatedTiles: mapAnimData,\n                active: true,\n                rate: 1,\n                activeLayer: []\n            };\n            map.layers.forEach(function () {\n                return animatedTiles.activeLayer.push(true);\n            });\n            this.animatedTiles.push(animatedTiles);\n            if (this.animatedTiles.length === 1) {\n                this.active = true; // Start the animations by default\n            }\n            /* Needed?\n            this.animatedTiles[this.animatedTiles.length-1].animatedTiles.forEach(\n                (animatedTile) => {\n                    animatedTile.tiles.forEach((layer) => {\n                        this.updateLayer(animatedTile,  layer);\n                    });\n                }\n            )*/\n        }\n    }, {\n        key: 'setRate',\n        value: function setRate(rate) {\n            var gid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            var map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n            if (gid === null) {\n                if (map === null) {\n                    this.rate = rate;\n                } else {\n                    this.animatedTiles[map].rate = rate;\n                }\n            } else {\n                var loopThrough = function loopThrough(animatedTiles) {\n                    animatedTiles.forEach(function (animatedTile) {\n                        if (animatedTile.index === gid) {\n                            animatedTile.rate = rate;\n                        }\n                    });\n                };\n                if (map === null) {\n                    this.animatedTiles.forEach(function (animatedTiles) {\n                        loopThrough(animatedTiles.animatedTiles);\n                    });\n                } else {\n                    loopThrough(this.animatedTiles[map].animatedTiles);\n                }\n            }\n            // if tile is number (gid) --> set rate for that tile\n            // TODO: if passing an object -> check properties matching object and set rate\n        }\n    }, {\n        key: 'resetRates',\n        value: function resetRates() {\n            var mapIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            if (mapIndex === null) {\n                this.rate = 1;\n                this.animatedTiles.forEach(function (mapAnimData) {\n                    mapAnimData.rate = 1;\n                    mapAnimData.animatedTiles.forEach(function (tileAnimData) {\n                        tileAnimData.rate = 1;\n                    });\n                });\n            } else {\n                this.animatedTiles[mapIndex].rate = 1;\n                this.animatedTiles[mapIndex].animatedTiles.forEach(function (tileAnimData) {\n                    tileAnimData.rate = 1;\n                });\n            }\n        }\n\n        //  Start (or resume) animations\n\n    }, {\n        key: 'resume',\n        value: function resume() {\n            var _this2 = this;\n\n            var layerIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n            var mapIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            var scope = mapIndex === null ? this : this.animatedTiles[mapIndex];\n            if (layerIndex === null) {\n                scope.active = true;\n            } else {\n                scope.activeLayer[layerIndex] = true;\n                scope.animatedTiles.forEach(function (animatedTile) {\n                    _this2.updateLayer(animatedTile, animatedTile.tiles[layerIndex]);\n                });\n            }\n        }\n\n        // Stop (or pause) animations\n\n    }, {\n        key: 'pause',\n        value: function pause() {\n            var layerIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n            var mapIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            var scope = mapIndex === null ? this : this.animatedTiles[mapIndex];\n            if (layerIndex === null) {\n                scope.active = false;\n            } else {\n                scope.activeLayer[layerIndex] = false;\n            }\n        }\n    }, {\n        key: 'postUpdate',\n        value: function postUpdate(time, delta) {\n            var _this3 = this;\n\n            if (!this.active) {\n                return;\n            }\n            // Elapsed time is the delta multiplied by the global rate and the scene timeScale if folowTimeScale is true\n            var globalElapsedTime = delta * this.rate * (this.followTimeScale ? this.scene.time.timeScale : 1);\n            this.animatedTiles.forEach(function (mapAnimData) {\n                if (!mapAnimData.active) {\n                    return;\n                }\n                // Multiply with rate for this map\n                var elapsedTime = globalElapsedTime * mapAnimData.rate;\n                mapAnimData.animatedTiles.forEach(function (animatedTile) {\n                    // Reduce time for current tile, multiply elapsedTime with this tile's private rate\n                    animatedTile.next -= elapsedTime * animatedTile.rate;\n                    // Time for current tile is up!!!\n                    if (animatedTile.next < 0) {\n                        // Remember current frame index\n                        var currentIndex = animatedTile.currentFrame;\n                        // Remember the tileId of current tile\n                        var oldTileId = animatedTile.frames[currentIndex].tileid;\n                        // Advance to next in line\n                        var newIndex = currentIndex + 1;\n                        // If we went beyond last frame, we just start over\n                        if (newIndex > animatedTile.frames.length - 1) {\n                            newIndex = 0;\n                        }\n                        // Set lifelength for current frame\n                        animatedTile.next = animatedTile.frames[newIndex].duration;\n                        // Set index of current frame\n                        animatedTile.currentFrame = newIndex;\n                        // Store the tileId (gid) we will shift to\n                        // Loop through all tiles (via layers)\n                        //this.updateLayer\n                        animatedTile.tiles.forEach(function (layer, layerIndex) {\n                            if (!mapAnimData.activeLayer[layerIndex]) {\n                                return;\n                            }\n                            _this3.updateLayer(animatedTile, layer, oldTileId);\n                        });\n                    }\n                }); // animData loop\n            }); // Map loop\n        }\n    }, {\n        key: 'updateLayer',\n        value: function updateLayer(animatedTile, layer) {\n            var oldTileId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n\n            var tilesToRemove = [];\n            var tileId = animatedTile.frames[animatedTile.currentFrame].tileid;\n            layer.forEach(function (tile) {\n                // If the tile is removed or has another index than expected, it's\n                // no longer animated. Mark for removal.\n                if (oldTileId > -1 && (tile === null || tile.index !== oldTileId)) {\n                    tilesToRemove.push(tile);\n                } else {\n                    // Finally we set the index of the tile to the one specified by current frame!!!\n                    tile.index = tileId;\n                }\n            });\n            // Remove obselete tiles\n            tilesToRemove.forEach(function (tile) {\n                var pos = layer.indexOf(tile);\n                if (pos > -1) {\n                    layer.splice(pos, 1);\n                } else {\n                    console.error(\"This shouldn't happen. Not at all. Blame Phaser Animated Tiles plugin. You'll be fine though.\");\n                }\n            });\n        }\n\n        //  Called when a Scene shuts down, it may then come back again later (which will invoke the 'start' event) but should be considered dormant.\n\n    }, {\n        key: 'shutdown',\n        value: function shutdown() {}\n\n        //  Called when a Scene is destroyed by the Scene Manager. There is no coming back from a destroyed Scene, so clear up all resources here.\n\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            this.shutdown();\n            this.scene = undefined;\n        }\n    }, {\n        key: 'getAnimatedTiles',\n        value: function getAnimatedTiles(map) {\n            var _this4 = this;\n\n            // this.animatedTiles is an array of objects with information on how to animate and which tiles.\n            var animatedTiles = [];\n            // loop through all tilesets\n            map.tilesets.forEach(\n            // Go through the data stored on each tile (not tile on the tilemap but tile in the tileset)\n            function (tileset) {\n                var tileData = tileset.tileData;\n                Object.keys(tileData).forEach(function (index) {\n                    index = parseInt(index);\n                    // If tile has animation info we'll dive into it\n                    if (tileData[index].hasOwnProperty(\"animation\")) {\n                        var animatedTileData = {\n                            index: index + tileset.firstgid, // gid of the original tile\n                            frames: [], // array of frames\n                            currentFrame: 0, // start on first frame\n                            tiles: [], // array with one array per layer with list of tiles that depends on this animation data\n                            rate: 1 // multiplier, set to 2 for double speed or 0.25 quarter speed\n                        };\n                        // push all frames to the animatedTileData\n                        tileData[index].animation.forEach(function (frameData) {\n                            var frame = {\n                                duration: frameData.duration,\n                                tileid: frameData.tileid + tileset.firstgid\n                            };\n                            animatedTileData.frames.push(frame);\n                        });\n                        // time until jumping to next frame\n                        animatedTileData.next = animatedTileData.frames[0].duration;\n                        // Go through all layers for tiles\n                        map.layers.forEach(function (layer) {\n                            if (layer.tilemapLayer.type === \"StaticTilemapLayer\") {\n                                // We just push an empty array if the layer is static (impossible to animate). \n                                // If we just skip the layer, the layer order will be messed up\n                                // when updating animated tiles and things will look awful.\n                                animatedTileData.tiles.push([]);\n                                return;\n                            }\n                            // tiles array for current layer\n                            var tiles = [];\n                            // loop through all rows with tiles...\n                            layer.data.forEach(function (tileRow) {\n                                // ...and loop through all tiles in that row\n                                tileRow.forEach(function (tile) {\n                                    // Tiled start index for tiles with 1 but animation with 0. Thus that wierd \"-1\"                                                    \n                                    if (tile.index - tileset.firstgid === index) {\n                                        tiles.push(tile);\n                                    }\n                                });\n                            });\n                            // add the layer's array with tiles to the tiles array.\n                            // this will make it possible to control layers individually in the future\n                            animatedTileData.tiles.push(tiles);\n                        });\n                        // animatedTileData is finished for current animation, push it to the animatedTiles-property of the plugin\n                        animatedTiles.push(animatedTileData);\n                    }\n                });\n            });\n            map.layers.forEach(function (layer, layerIndex) {\n                // layer indices array of booleans whether to animate tiles on layer or not\n                _this4.activeLayer[layerIndex] = true;\n            });\n\n            return animatedTiles;\n        }\n    }, {\n        key: 'putTileAt',\n        value: function putTileAt(layer, tile, x, y) {\n            // Replaces putTileAt of the native API, but updates the list of animatedTiles in the process.\n            // No need to call updateAnimatedTiles as required for other modificatons of the tile-map\n        }\n    }, {\n        key: 'updateAnimatedTiles',\n        value: function updateAnimatedTiles() {\n            // future args: x=null, y=null, w=null, h=null, container=null \n            var x = null,\n                y = null,\n                w = null,\n                h = null,\n                container = null;\n            // 1. If no container, loop through all initilized maps\n            if (container === null) {\n                container = [];\n                this.animatedTiles.forEach(function (mapAnimData) {\n                    container.push(mapAnimData);\n                });\n            }\n            // 2. If container is a map, loop through it's layers\n            // container = [container];\n\n            // 1 & 2: Update the map(s)\n            container.forEach(function (mapAnimData) {\n                var chkX = x !== null ? x : 0;\n                var chkY = y !== null ? y : 0;\n                var chkW = w !== null ? mapAnimData.map.width : 10;\n                var chkH = h !== null ? mapAnimData.map.height : 10;\n\n                mapAnimData.animatedTiles.forEach(function (tileAnimData) {\n                    tileAnimData.tiles.forEach(function (tiles, layerIndex) {\n                        var layer = mapAnimData.map.layers[layerIndex];\n                        if (layer.type === \"StaticTilemapLayer\") {\n                            return;\n                        }\n                        for (var _x9 = chkX; _x9 < chkX + chkW; _x9++) {\n                            for (var _y = chkY; _y < chkY + chkH; _y++) {\n                                var tile = mapAnimData.map.layers[layerIndex].data[_x9][_y];\n                                // should this tile be animated?\n                                if (tile.index == tileAnimData.index) {\n                                    // is it already known? if not, add it to the list\n                                    if (tiles.indexOf(tile) === -1) {\n                                        tiles.push(tile);\n                                    }\n                                    // update index to match current fram of this animation\n                                    tile.index = tileAnimData.frames[tileAnimData.currentFrame].tileid;\n                                }\n                            }\n                        }\n                    });\n                });\n            });\n            // 3. If container is a layer, just loop through it's tiles\n        }\n    }]);\n\n    return AnimatedTiles;\n}(Phaser.Plugins.ScenePlugin);\n\n;\n\n//  Static function called by the PluginFile Loader.\nAnimatedTiles.register = function (PluginManager) {\n    //  Register this plugin with the PluginManager, so it can be added to Scenes.\n    PluginManager.register('AnimatedTiles', AnimatedTiles, 'animatedTiles');\n};\n\nmodule.exports = AnimatedTiles;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}